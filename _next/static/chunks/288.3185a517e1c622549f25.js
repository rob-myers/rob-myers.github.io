"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[288],{5288:function(n,e,t){t.r(e),e.default='import React from "react";\nimport { css } from "goober";\nimport { useQuery } from "react-query";\n\nimport * as defaults from "./defaults";\nimport { Poly, Rect, Vect } from "../geom";\nimport { geom } from "../service/geom";\nimport { Pathfinding } from \'../pathfinding/Pathfinding\';\nimport { geomorphJsonPath, geomorphPngPath } from "../geomorph/geomorph.model";\n\nimport PanZoom from "../panzoom/PanZoom";\nimport DraggableNode from "../ui/DraggableNode";\nimport classNames from "classnames";\n\n// TODO\n// - also show zig-zag path\n\n/** @param {{ disabled?: boolean }} props */\nexport default function NavStringPull(props) {\n\n  const [state] = React.useState(() => ({\n    /** @type {SVGGElement} */\n    rootEl: ({}),\n    /** @type {SVGCircleElement} */\n    targetEl: ({}),\n    /** @type {SVGPolylineElement} */\n    pathEl: ({}),\n\n    source: new Vect(300, 300),\n    target: new Vect(600, 300),\n    path: /** @type {Vect[]} */ ([]),\n\n    updatePath: () => {\n      const groupId = pathfinding.getGroup(zoneKey, state.source);\n      if (groupId !== null) {\n        state.path = [state.source.clone()].concat(pathfinding.findPath(state.source, state.target, zoneKey, groupId) || []);\n        state.pathEl.setAttribute(\'points\', `${state.path}`);\n      }\n    },\n  }));\n  \n  const pathfinding = React.useMemo(() => new Pathfinding, []);\n  const { data } = useQuery(\'navpoly-demo\', async () => {\n    /** @type {Geomorph.GeomorphJson} */\n    const json = await fetch(geomorphJsonPath(\'g-301--bridge\')).then(x => x.json());\n    const navPoly = json.navPoly.map(x => Poly.from(x));\n    const decomp = geom.polysToTriangulation(navPoly);\n    const zone = Pathfinding.createZone(decomp);\n    pathfinding.setZoneData(zoneKey, zone);\n    return { pngRect: json.pngRect, navPoly, zone };\n  });\n\n  return (\n    <PanZoom gridBounds={defaults.gridBounds} initViewBox={initViewBox} maxZoom={6}>\n      <g\n        className={classNames(rootCss, !props.disabled && animateNavpathCss)}\n        ref={(el) => {\n          if (el) {\n            state.rootEl = el;\n            state.pathEl = /** @type {SVGPolylineElement} */ (el.querySelector(\'polyline.navpath\'));\n            state.updatePath();\n          }\n        }}\n      >\n\n        {data && <>\n          <image {...data.pngRect} className="geomorph" href={geomorphPngPath(\'g-301--bridge\')} />\n\n          {data.zone.groups.map(nodes => nodes.map(({ vertexIds}) =>\n            <polygon className="navtri" points={`${vertexIds.map(id => data.zone.vertices[id])}`} />\n          ))}\n        </>}\n\n        <polyline className="navpath" points={`${state.path}`}/>\n\n        <DraggableNode\n          initial={state.source}\n          radius={8}\n          onStop={(p) => {\n            state.source.copy(p);\n            state.updatePath();\n          }}\n          icon="run"\n        />\n\n        <DraggableNode\n          initial={state.target}\n          radius={8}\n          onStop={(p) => {\n            state.target.copy(p);\n            state.updatePath();\n          }}\n          icon="finish"\n        />\n\n      </g>\n\n    </PanZoom>\n  );\n}\n\nconst rootCss = css`\n  border: 1px solid #555555;\n  height: inherit;\n\n  polyline.navpath {\n    fill: none;\n    stroke: #083;\n    stroke-width: 4;\n    stroke-dasharray: 8px;\n    stroke-dashoffset: 16px;\n  }\n\n  @keyframes flash {\n    0% { stroke-dashoffset: 16px; }\n    100% { stroke-dashoffset: 0px; }\n  }\n\n  polygon.navtri {\n    fill: transparent;\n    &:hover {\n      stroke: #900;\n    }\n  }\n`;\n\nconst animateNavpathCss = css`\n  polyline.navpath {\n    animation: 600ms flash infinite linear;\n  }\n`;\n\nconst zoneKey = \'NavStringPullZone\';\nconst initViewBox = new Rect(200, 0, 600, 600);\n'}}]);