"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[451],{70451:function(n,t,i){i.r(t),t.default="import { Vect } from './vect';\n\n/**\n * A two dimensional rectangle where `(x, y)` is viewed as top left.\n */\nexport class Rect {\n  /**\n   * @param {number} x \n   * @param {number} y \n   * @param {number} width \n   * @param {number} height \n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /** @type {number} */ this.x = x;\n    /** @type {number} */ this.y = y;\n    /** @type {number} */ this.width = width;\n    /** @type {number} */ this.height = height;\n  }\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get bottomLeft() {\n    return new Vect(this.x, this.y + this.height);\n  }\n\n  get bottomRight() {\n    return new Vect(this.x + this.width, this.y + this.height);\n  }\n\n  get center() {\n    return new Vect(this.cx, this.cy);\n  }\n\n  get cx() {\n    return this.x + 0.5 * this.width;\n  }\n\n  get cy() {\n    return this.y + 0.5 * this.height;\n  }\n\n  /** @returns {Geom.GeoJsonPolygon} */\n  get geoJson() {\n    return {\n      type: 'Polygon',\n      coordinates: [\n        [\n          [this.x, this.y],\n          [this.x + this.width, this.y],\n          [this.x + this.width, this.y + this.height],\n          [this.x, this.y + this.height]\n        ]\n      ]\n    };\n  }\n\n  /** @returns {Geom.RectJson} */\n  get json() {\n    return { \n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n    };\n  }\n\n  get key() {\n    return `${this.x},${this.y},${this.width},${this.height}`;\n  }\n\n  get dimension() {\n    return Math.max(this.width, this.height);\n  }\n\n  /**\n   * Anti-clockwise w.r.t y being downwards\n   * @returns {[Vect, Vect, Vect, Vect]}\n   */\n  get points() {\n    return [\n      new Vect(this.x, this.y),\n      new Vect(this.x, this.y + this.height),\n      new Vect(this.x + this.width, this.y + this.height),\n      new Vect(this.x + this.width, this.y),\n    ];\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get topLeft() {\n    return new Vect(this.x, this.y);\n  }\n\n  get topRight() {\n    return new Vect(this.x + this.width, this.y);\n  }\n\n  static get zero() {\n    return new Rect(0, 0, 0, 0);\n  }\n\n  /** @param {import('./mat').Mat} m */\n  applyMatrix(m) {\n    if (!m.isIdentity) {\n      const min = m.transformPoint(this.topLeft);\n      const max = m.transformPoint(this.bottomRight);\n      this.x = Math.min(min.x, max.x);\n      this.y = Math.min(min.y, max.y);\n      this.width = Math.max(min.x, max.x) - this.x;\n      this.height = Math.max(min.y, max.y) - this.y;\n    }\n    return this;\n  }\n\n  clone() {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n\n  /** @param {Geom.VectJson} _ */\n  contains({ x, y }) {\n    return this.x <= x && x <= this.x + this.width && (this.y <= y && y <= this.y + this.height);\n  }\n\n  /** @param {Geom.RectJson} _ */\n  copy({ x, y, width, height }) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  /** @param {Rect} _ */\n  covers({ x, y, width, height }) {\n    return (\n      this.x <= x &&\n      x + width <= this.x + this.width &&\n      this.y <= y &&\n      y + height <= this.y + this.height\n    );\n  }\n\n  /**\n   * @param {number} dx \n   * @param {number} dy \n   */\n  delta(dx, dy) {\n    this.x += dx;\n    this.y += dy;\n    return this;\n  }\n\n  /** \n   * Returns `Rect2.zero` if no args.\n   * @param {Vect[] | Rect[]} items\n   */\n  static from(...items) {\n    if (!items.length) {\n      return Rect.zero;\n    } else if (items[0] instanceof Vect) {\n      const vectors = /** @type {Vect[]} */ (items);\n      const mx = Math.min(...vectors.map(({ x }) => x));\n      const my = Math.min(...vectors.map(({ y }) => y));\n      const Mx = Math.max(...vectors.map(({ x }) => x));\n      const My = Math.max(...vectors.map(({ y }) => y));\n      return new Rect(mx, my, Mx - mx, My - my);\n    } else {\n      const rects = /** @type {Rect[]} */ (items);\n      const mx = Math.min(...rects.map(({ x }) => x));\n      const my = Math.min(...rects.map(({ y }) => y));\n      const Mx = Math.max(...rects.map(({ x, width }) => x + width));\n      const My = Math.max(...rects.map(({ y, height }) => y + height));\n      return new Rect(mx, my, Mx - mx, My - my);\n    }\n  }\n\n  /** @param {Geom.RectJson} _ */\n  static fromJson({ x, y, width, height }) {\n    return new Rect(x, y, width, height);\n  }\n\n  /**\n   * Bounded version of `lambda x.this.outset(-x)`\n   * @param {number} nonNegAmount \n   */\n  inset(nonNegAmount) {\n    const [cx, cy] = [this.cx, this.cy];\n    this.outset(-nonNegAmount);\n    if (this.width < 0) {\n      this.x = cx;\n      this.width = 0;\n    }\n    if (this.height < 0) {\n      this.y = cy;\n      this.height = 0;\n    }\n    return this;\n  }\n\n  /**\n   * Does this filled bordered rectangle intersect with {other} filled rectangle?\n   * @param {Rect} other\n   */\n  intersects(other) {\n    return (\n      Math.abs(this.cx - other.cx) * 2 <= this.width + other.width &&\n      Math.abs(this.cy - other.cy) * 2 <= this.height + other.height\n    );\n  }\n\n  /** @param {Geom.VectJson} _ */\n  offset({ x, y }) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  /**\n   * @param {number} nonNegDx \n   * @param {number} [nonNegDy]\n   */\n  outset(nonNegDx, nonNegDy = nonNegDx) {\n    this.x -= nonNegDx;\n    this.y -= nonNegDy;\n    this.width += 2 * nonNegDx;\n    this.height += 2 * nonNegDy;\n    return this;\n  }\n\n  /**\n   * Mutate precision.\n   * @param {number} dp decimal places\n   */\n  precision(dp) {\n    return this.set(\n      Number(this.x.toFixed(dp)),\n      Number(this.y.toFixed(dp)),\n      Number(this.width.toFixed(dp)),\n      Number(this.height.toFixed(dp)),\n    );\n  }\n\n  /** @param {number} k */\n  scale(k) {\n    this.x *= k;\n    this.y *= k;\n    this.width *= k;\n    this.height *= k;\n    return this;\n  }\n\n  /**\n   * @param {number} x \n   * @param {number} y \n   * @param {number} w \n   * @param {number} h \n   */\n  set(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.width = w;\n    this.height = h;\n    return this;\n  }\n\n  /** @param {Geom.RectJson} _ */\n  setFromJson({ x, y, width, height }) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  /** @param {Geom.VectJson} position */\n  setPosition(position) {\n    this.x = position.x;\n    this.y = position.y;\n    return this;\n  }\n\n  toString() {\n    return `${this.x},${this.y},${this.width},${this.height}`;\n  }\n\n}\n"}}]);