import { useEffect } from 'react';
import Head from 'next/head'
import styled from "@emotion/styled";

import Header from 'components/page/Header';
import Markdown from 'components/page/Markdown';
import { CodeEdit } from 'components/dynamic';
import Terminal from 'components/sh/Terminal';
import { Section } from 'components/page/Layout';
import useCodeStore from 'store/code.store';

export default function IndexPage() {

  useEffect(() => {
    useCodeStore.api.rehydrate(['file.js']);
  }, []);

  return (
    <>
      <Head>
        <title>Hot modules</title>
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Main>
        <Header />
        <Section>
          <Markdown children={`
## Introduction

In the beginning, Brendan Eich made LiveScript.
It was subsequently renamed _JavaScript_.
It is now the only programming language supported by all web browsers. JavaScript (JS) has two siblings i.e. HTML (hierarchy of elements on a webpage) and CSS (their look and feel). It subsumes them both,
- e.g. via [JSX](https://en.wikipedia.org/wiki/JSX_(JavaScript)) (syntactic sugar) and [tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) (added in ES6) combined with runtime DOM diffing.
- e.g. via template languages which compile to JS.

Even though visiting a website begins by downloading HTML, the latter is often generated by JS running on a server. Then browsing a website amounts to running JavaScript, initially remotely and subsequently on our own machine. The resulting stateful application depends on user input, various kinds of local storage and also API responses i.e. the backend infrastructure.

While browsing a website we may run _additional JavaScript_ e.g. advert blockers and password autofillers. This saves time and improves the browsing experience. The development of websites follows a similar pattern. 

> The developer _also_ browses the site, but runs JS autogenerated from the source code on their own machine. They run additional JS in the browser, in order to _sync the website with the autogenerated JS_. This saves time and improves the development experience.


Here's the simplest example: a JSX source file is changed, a new JS file is somehow autogenerated, the browser-based additional JS is somehow informed, finally it decides to trigger a full page reload. However, refreshing a webpage is not unlike rebooting an application...

...

But web developers also want to make edits without reloading (as much as possible). Understanding _exactly what that means_ is the subject of this website.

- Easier to learn by making small changes
- Richer UIs possible via text
- Against the norm we will explicitly download code via a shell...

---


- shell via xterm.js and mvdan-sh
- ace-editor with tabs
- webworker with forked @babel/standalone
- service worker
- systemjs modules
- preact.js + linaria
- react-query + zustand

`}/>
        </Section>

        <section style={{ height: 300, width: '100%' }}>
          <CodeEdit codeKey="file.js"/>
        </section>

        <section style={{ height: 300 }}>
          <Terminal sessionKey="test" env={env} />
        </section>

      </Main>
    </>
  );
}

const env = {};

const Main = styled.main<{}>`
  display: flex;
  flex-direction: column;
  padding-bottom: 2rem;
  max-width: 1000px;
  margin: 0 auto;

  @media(max-width: 1024px) {
    margin: 0 3rem;
    justify-content: unset;
  }
  @media(max-width: 700px) {
    margin: 0;
  }
`;
